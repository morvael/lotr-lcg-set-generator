# pylint: disable=C0103,W0703
# -*- coding: utf8 -*-
""" Discord bot.

You need to install dependency:
pip install discord.py
"""
import asyncio
import json
import logging
import os
import re

import discord
import yaml

import lotr


CONF_PATH = 'discord.yaml'
LOG_PATH = 'discord_bot.log'
PLAYTEST_PATH = os.path.join('Discord', 'playtest.json')
WORKING_DIRECTORY = '/home/homeassistant/lotr-lcg-set-generator/'

PLAYTEST_CHANNEL_ID = 821853410084651048

SLEEP_TIME = 1

playtest_lock = asyncio.Lock()


def init_logging():
    """ Init logging.
    """
    logging.basicConfig(filename=LOG_PATH, level=logging.INFO,
                        format='%(asctime)s %(levelname)s: %(message)s')


def get_token():
    """ Get Discord token.
    """
    try:
        with open(CONF_PATH, 'r') as f_conf:
            conf = yaml.safe_load(f_conf)

        return conf.get('token', '')
    except Exception as exc:
        logging.exception(str(exc))
        return ''


async def get_log():
    """ Get full log of the last cron execution.
    """
    try:
        proc = await asyncio.create_subprocess_shell(
            './cron_log.sh',
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE)
        stdout, _ = await proc.communicate()
    except Exception:
        return ''

    res = stdout.decode('utf-8').strip()
    return res


async def get_errors():
    """ Get errors of the last cron execution.
    """
    try:
        proc = await asyncio.create_subprocess_shell(
            './cron_errors.sh',
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE)
        stdout, _ = await proc.communicate()
    except Exception:
        return ''

    res = stdout.decode('utf-8').strip()
    return res


def split_result(value):
    """ Split result into chunks.
    """
    res = []
    chunk = ''
    for line in value.split('\n'):
        if len(chunk + line) + 1 <= 1900:
            chunk += line + '\n'
        else:
            res.append(chunk)
            chunk = line + '\n'

    res.append(chunk)
    return res


def format_playtest_message(data):
    """ Format playtest message to post to Discord.
    """
    res = ''
    if data['description']:
        res += '{}\n'.format(data['description'])

    for line in data['targets']:
        completed = '~~' if line['completed'] else ''
        user = ' ({})'.format(line['user']) if line['user'] else ''
        res += '{}{}. {}{}{}\n'.format(completed,  # pylint: disable=W1308
                                       line['num'],
                                       line['title'],
                                       completed,
                                       user)

    res = res.strip()
    return res


async def read_card_data():
    """ Read card data generated by the cron job.
    """
    try:
        with open(lotr.DISCORD_CARD_DATA_PATH, 'r') as obj:
            data = json.load(obj)
    except Exception:
        await asyncio.sleep(SLEEP_TIME)
        with open(lotr.DISCORD_CARD_DATA_PATH, 'r') as obj:
            data = json.load(obj)

    return data


def match(card_name, search_name):
    """ Compare a search name with a card name.
    """
    if search_name == card_name:
        return 1

    if card_name.startswith(search_name + '-'):
        return 2

    if card_name.startswith(search_name):
        return 3

    return 0


def format_card(card):
    """ Format the card.
    """
    name = card.get(lotr.CARD_NAME, '')
    if name != '':
        name = '**{}**'.format(name)

    card_type = card.get(lotr.CARD_TYPE, '')

    sphere = card.get(lotr.CARD_SPHERE, '')
    if sphere == 'Lore':
        sphere_icon = '<:lore:822573464678301736> '
        sphere = '*Lore* '
    elif sphere == 'Spirit':
        sphere_icon = '<:spirit:822573464417206273> '
        sphere = '*Spirit* '
    elif sphere == 'Tactics':
        sphere_icon = '<:tactics:822573464593629264> '
        sphere = '*Tactics* '
    elif sphere == 'Leadership':
        sphere_icon = '<:leadership:822573464601886740> '
        sphere = '*Leadership* '
    elif sphere == 'Baggins':
        sphere_icon = '<:baggins:822573762415296602> '
        sphere = '*Baggins* '
    elif sphere == 'Fellowship':
        sphere_icon = '<:fellowship:822573464586027058> '
        sphere = '*Fellowship* '
    elif sphere in ('Neutral', 'Boon', 'Burden', 'Nightmare', 'Upgraded'):
        sphere_icon = ''
        sphere = '*{}* '.format(sphere)
    else:
        sphere_icon = ''
        sphere = ''

    cost = card.get(lotr.CARD_COST, '')
    if cost != '':
        if card_type == 'Hero':
            cost = ', *Threat Cost*: **{}**'.format(cost)
        elif card_type == 'Quest':
            cost = ''
        else:
            cost = ', *Cost*: **{}**'.format(cost)

    res = f"""
{sphere_icon}{name}
{sphere}{card_type}{cost}
    """
    return res


async def get_card(command, category=''):
    """ Get the card information.
    """
    data = await read_card_data()
    if re.match(r' [0-9]+$', command):
        parts = command.split(' ')
        name = ' '.join(parts[:-1])
        num = parts[-1]
    else:
        name = command
        num = 1

    name = lotr.normalized_name(name)
    matches = [m for m in [
        (card, match(card.get(lotr.CARD_NORMALIZED_NAME, ''), name))
        for card in data] if m[1] > 0]
    if not matches:
        return 'no cards found'

    matches.sort(key=lambda m: (m[1], m[0].get(lotr.CARD_NAME, '')))
    return format_card(matches[num - 1][0])


class MyClient(discord.Client):
    """ My bot class.
    """

    async def on_ready(self):
        """ Invoked when the client is ready.
        """
        logging.info('Logged in as %s (%s)', self.user.name, self.user.id)


    async def _process_cron_command(self, message):  #pylint: disable=R0912
        """ Process a cron command.
        """
        command = re.sub(r'^!cron ', '', message.content).split('\n')[0]
        logging.info('Received cron command: %s', command)
        if command == 'hello':
            await message.channel.send('hello')
        elif command == 'test':
            await message.channel.send('passed')
        elif command == 'thank you':
            await message.channel.send('you are welcome')
        elif command == 'log':
            res = await get_log()
            if not res:
                res = 'no cron log found'

            for i, chunk in enumerate(split_result(res)):
                if i > 0:
                    await asyncio.sleep(SLEEP_TIME)

                await message.channel.send(chunk)
        elif command == 'errors':
            res = await get_errors()
            if not res:
                res = 'no cron log found'

            for i, chunk in enumerate(split_result(res)):
                if i > 0:
                    await asyncio.sleep(SLEEP_TIME)

                await message.channel.send(chunk)
        else:
            await message.channel.send('excuse me?')


    async def _new_target(self, content):
        """ Set new playtesting targets.
        """
        error_message = """incorrect command format: {}
try something like:
```
!playtest new
Deadline: tomorrow.
1. Escape From Dol Guldur (solo)
2. Frogs deck
```
"""
        lines = [line.strip() for line in content.split('\n')[1:]]
        nums = set()
        description = []
        targets = []
        for line in lines:
            if not re.match(r'^[0-9]+\.? ', line):
                if nums:
                    return error_message.format('no number for a target')

                description.append(line)
                continue

            if '~~' in line:
                return error_message.format('a target is already crossed out')

            num, title = line.split(' ', 1)
            num = re.sub(r'\.$', '', num)
            if num in nums:
                return error_message.format(
                    'a duplicate target number "{}"'.format(num))

            nums.add(num)
            targets.append({'num': num,
                            'title': title,
                            'completed': False,
                            'user': None})

        if not targets:
            return error_message.format('no targets specified')

        data = {'targets': targets,
                'description': '\n'.join(description)}

        async with playtest_lock:
            with open(PLAYTEST_PATH, 'w') as obj:
                json.dump(data, obj)

        playtest_message = """----------
New playtesting targets:
{}""".format(format_playtest_message(data))
        await self.get_channel(PLAYTEST_CHANNEL_ID).send(playtest_message)
        return ''


    async def _complete_target(self, content, num, user, url):
        """ Complete playtesting target.
        """
        if not re.match(r'^[0-9]+$', num):
            return 'target number "{}" doesn\'t look correct'.format(num)

        if len(content.split('\n', 1)) == 1:
            return 'please add a playtesting report'

        async with playtest_lock:
            with open(PLAYTEST_PATH, 'r+') as obj:
                data = json.load(obj)

                nums = [target['num'] for target in data['targets']]
                if num not in nums:
                    return 'target "{}" not found'.format(num)

                nums = [target['num'] for target in data['targets']
                        if not target['completed']]
                if num not in nums:
                    return 'target "{}" already completed'.format(num)

                for target in data['targets']:
                    if target['num'] == num:
                        target['completed'] = True
                        target['user'] = user
                        break

                obj.seek(0)
                obj.truncate()
                json.dump(data, obj)

        all_targets = ('All targets completed now!'
                       if all(target['completed']
                              for target in data['targets'])
                       else '')
        playtest_message = """----------
Target "{}" completed. Link: {}
{}
{}""".format(num, url, format_playtest_message(data), all_targets)
        await self.get_channel(PLAYTEST_CHANNEL_ID).send(playtest_message)
        return ''


    async def _update_target(self, params):
        """ Update playtesting target.
        """
        nums = set()
        while params:
            param = params[0]
            if not param:
                params.pop(0)
            elif re.match(r'^[0-9]+$', param):
                if param in nums:
                    return 'a duplicate target number "{}"'.format(param)

                params.pop(0)
                nums.add(param)
            else:
                break

        if not nums:
            return 'no target number(s) specified'

        user = ' '.join(params)
        async with playtest_lock:
            with open(PLAYTEST_PATH, 'r+') as obj:
                data = json.load(obj)

                existing_nums = set(target['num']
                                    for target in data['targets'])
                for num in nums:
                    if num not in existing_nums:
                        return 'target "{}" not found'.format(num)

                for target in data['targets']:
                    if target['num'] in nums:
                        if user:
                            target['completed'] = True
                            target['user'] = user
                        else:
                            target['completed'] = False
                            target['user'] = None

                obj.seek(0)
                obj.truncate()
                json.dump(data, obj)

        all_targets = ('All targets completed now!'
                       if all(target['completed']
                              for target in data['targets'])
                       else '')
        playtest_message = """----------
Targets updated.
{}
{}""".format(format_playtest_message(data), all_targets)
        await self.get_channel(PLAYTEST_CHANNEL_ID).send(playtest_message)
        return ''


    async def _add_target(self, content):
        """ Add additional playtesting targets.
        """
        lines = [line.strip() for line in content.split('\n')[1:]]
        nums = set()
        description = []
        targets = []
        for line in lines:
            if not re.match(r'^[0-9]+\.? ', line):
                if nums:
                    return 'no number for a target'

                description.append(line)
                continue

            if '~~' in line:
                return 'a target is already crossed out'

            num, title = line.split(' ', 1)
            num = re.sub(r'\.$', '', num)
            if num in nums:
                return 'a duplicate target number "{}"'.format(num)

            nums.add(num)
            targets.append({'num': num,
                            'title': title,
                            'completed': False,
                            'user': None})

        if not description and not targets:
            return 'no new desription or targets specified'

        async with playtest_lock:
            with open(PLAYTEST_PATH, 'r+') as obj:
                data = json.load(obj)

                existing_nums = set(target['num']
                                    for target in data['targets'])
                for num in nums:
                    if num in existing_nums:
                        return 'a duplicate target number "{}"'.format(num)

                if description:
                    data['description'] = '\n'.join(description)

                data['targets'].extend(targets)
                obj.seek(0)
                obj.truncate()
                json.dump(data, obj)

        playtest_message = """----------
Targets added.
{}""".format(format_playtest_message(data))
        await self.get_channel(PLAYTEST_CHANNEL_ID).send(playtest_message)
        return ''


    async def _remove_target(self, params):
        """ Remove existing playtesting targets.
        """
        nums = set()
        while params:
            param = params[0]
            if not param:
                params.pop(0)
            elif re.match(r'^[0-9]+$', param):
                if param in nums:
                    return 'a duplicate target number "{}"'.format(param)

                params.pop(0)
                nums.add(param)
            else:
                return 'target number "{}" doesn\'t look correct'.format(param)

        if not nums:
            return 'no target number(s) specified'

        async with playtest_lock:
            with open(PLAYTEST_PATH, 'r+') as obj:
                data = json.load(obj)

                existing_nums = set(target['num']
                                    for target in data['targets'])
                for num in nums:
                    if num not in existing_nums:
                        return 'target "{}" not found'.format(num)

                data['targets'] = [target for target in data['targets']
                                   if target['num'] not in nums]
                obj.seek(0)
                obj.truncate()
                json.dump(data, obj)

        playtest_message = """----------
Targets removed.
{}""".format(format_playtest_message(data))
        await self.get_channel(PLAYTEST_CHANNEL_ID).send(playtest_message)
        return ''


    async def _process_playtest_command(self, message):  # pylint: disable=R0911,R0912,R0915
        """ Process a playtest command.
        """
        command = re.sub(r'^!playtest ', '', message.content).split('\n')[0]
        logging.info('Received playtest command: %s', command)
        if command == 'new':
            try:
                error = await self._new_target(message.content)
            except Exception as exc:
                logging.error(str(exc))
                await message.channel.send(
                    'unexpected error: {}'.format(str(exc)))
                return

            if error:
                await message.channel.send(error)
                return

            await message.channel.send('done')
        elif command.startswith('complete '):
            try:
                num = re.sub(r'^complete ', '', command)
                user = re.sub(r'#.+$', '', str(message.author))
                error = await self._complete_target(message.content, num, user,
                                                    message.jump_url)
            except Exception as exc:
                logging.error(str(exc))
                await message.channel.send(
                    'unexpected error: {}'.format(str(exc)))
                return

            if error:
                await message.channel.send(error)
                return

            await message.channel.send('done')
        elif command.startswith('update '):
            try:
                params = re.sub(r'^update ', '', command).split(' ')
                error = await self._update_target(params)
            except Exception as exc:
                logging.error(str(exc))
                await message.channel.send(
                    'unexpected error: {}'.format(str(exc)))
                return

            if error:
                await message.channel.send(error)
                return

            await message.channel.send('done')
        elif command == 'add':
            try:
                error = await self._add_target(message.content)
            except Exception as exc:
                logging.error(str(exc))
                await message.channel.send(
                    'unexpected error: {}'.format(str(exc)))
                return

            if error:
                await message.channel.send(error)
                return

            await message.channel.send('done')
        elif command.startswith('remove '):
            try:
                params = re.sub(r'^remove ', '', command).split(' ')
                error = await self._remove_target(params)
            except Exception as exc:
                logging.error(str(exc))
                await message.channel.send(
                    'unexpected error: {}'.format(str(exc)))
                return

            if error:
                await message.channel.send(error)
                return

            await message.channel.send('done')
        else:
            await message.channel.send('excuse me?')


    async def _process_card_command(self, message):
        """ Process a card command.
        """
        command = re.sub(r'^!alepcard ', '', message.content).split('\n')[0]
        logging.info('Received card command: %s', command)
        if command == 'this':
            command = message.channel.name
            category = message.channel.category
        else:
            category = ''

        try:
            res = await get_card(command, category)
        except Exception as exc:
            logging.error(str(exc))
            await message.channel.send(
                'unexpected error: {}'.format(str(exc)))
            return

        await message.channel.send(res)


    async def on_message(self, message):
        """ Invoked when a new message posted.
        """
        try:
            if message.author.id == self.user.id:
                return

            if message.content.startswith('!cron '):
                await self._process_cron_command(message)
            elif message.content.startswith('!playtest '):
                await self._process_playtest_command(message)
            elif message.content.startswith('!alepcard '):
                await self._process_card_command(message)
        except Exception as exc:
            logging.exception(str(exc))


if __name__ == '__main__':
    os.chdir(WORKING_DIRECTORY)
    init_logging()
    MyClient().run(get_token())
