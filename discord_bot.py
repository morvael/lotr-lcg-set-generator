# pylint: disable=C0103,W0703
# -*- coding: utf8 -*-
""" Discord bot.

You need to install dependency:
pip install discord.py

Create discord.yaml (see discord.default.yaml).
"""
import asyncio
import json
import logging
import os
import random
import re

import discord
import yaml

import lotr


CONF_PATH = 'discord.yaml'
LOG_PATH = 'discord_bot.log'
PLAYTEST_PATH = os.path.join('Discord', 'playtest.json')
WORKING_DIRECTORY = '/home/homeassistant/lotr-lcg-set-generator/'

SLEEP_TIME = 1

EMOJIS = {
    '[leadership]': '<:leadership:822573464601886740>',
    '[lore]': '<:lore:822573464678301736>',
    '[spirit]': '<:spirit:822573464417206273>',
    '[tactics]': '<:tactics:822573464593629264>',
    '[baggins]': '<:baggins:822573762415296602>',
    '[fellowship]': '<:fellowship:822573464586027058>',
    '[unique]': '<:unique:822573762474016818>',
    '[threat]': '<:threat:822572608994148362>',
    '[attack]': '<:attack:822573464367792221>',
    '[defense]': '<:defense:822573464615518209>',
    '[willpower]': '<:willpower:822573464367792170>',
    '[sunny]': '[sunny]',
    '[cloudy]': '[cloudy]',
    '[rainy]': '[rainy]',
    '[stormy]': '[stormy]',
    '[sailing]': '[sailing]',
    '[eos]': '[eos]',
    '[pp]': '<:pp:823008093898145792>',
    '[hitpoints]': '<:hitpoints:822572931254714389>',
    '[progress]': '<:progress:823007871494520872>'
}
PLAYTEST_CHANNEL = 'playtesting-checklist'

playtest_lock = asyncio.Lock()


def init_logging():
    """ Init logging.
    """
    logging.basicConfig(filename=LOG_PATH, level=logging.INFO,
                        format='%(asctime)s %(levelname)s: %(message)s')


def get_token():
    """ Get Discord token.
    """
    try:
        with open(CONF_PATH, 'r') as f_conf:
            conf = yaml.safe_load(f_conf)

        return conf.get('token', '')
    except Exception as exc:
        logging.exception(str(exc))
        return ''


async def get_log():
    """ Get full log of the last cron execution.
    """
    try:
        proc = await asyncio.create_subprocess_shell(
            './cron_log.sh',
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE)
        stdout, _ = await proc.communicate()
    except Exception:
        return ''

    res = stdout.decode('utf-8').strip()
    return res


async def get_errors():
    """ Get errors of the last cron execution.
    """
    try:
        proc = await asyncio.create_subprocess_shell(
            './cron_errors.sh',
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE)
        stdout, _ = await proc.communicate()
    except Exception:
        return ''

    res = stdout.decode('utf-8').strip()
    return res


def split_result(value):
    """ Split result into chunks.
    """
    res = []
    chunk = ''
    for line in value.split('\n'):
        if len(chunk + line) + 1 <= 1900:
            chunk += line + '\n'
        else:
            res.append(chunk)
            chunk = line + '\n'

    res.append(chunk)
    return res


def format_playtest_message(data):
    """ Format playtest message to post to Discord.
    """
    res = ''
    if data['description']:
        res += '{}\n'.format(data['description'])

    for line in data['targets']:
        completed = '~~' if line['completed'] else ''
        user = ' ({})'.format(line['user']) if line['user'] else ''
        res += '{}{}. {}{}{}\n'.format(completed,  # pylint: disable=W1308
                                       line['num'],
                                       line['title'],
                                       completed,
                                       user)

    res = res.strip()
    return res


async def read_card_data():
    """ Read card data generated by the cron job.
    """
    try:
        with open(lotr.DISCORD_CARD_DATA_PATH, 'r') as obj:
            data = json.load(obj)
    except Exception:
        await asyncio.sleep(SLEEP_TIME)
        with open(lotr.DISCORD_CARD_DATA_PATH, 'r') as obj:
            data = json.load(obj)

    return data


def card_match(card_name, card_back_name, search_name):
    """ Compare a search name with a card name.
    """
    if search_name in (card_name, card_back_name):
        return 1

    if (card_name.startswith(search_name + '-') or
            card_back_name.startswith(search_name + '-')):
        return 2

    if (card_name.startswith(search_name) or
            card_back_name.startswith(search_name)):
        return 3

    return 0


def update_text(text):
    """ Update card text.
    """
    text = re.sub(r'\b(Quest Resolution)( \([^\)]+\))?:', '[b]\\1[/b]\\2:', text)
    text = re.sub(r'\b(Valour )?(Resource |Planning |Quest |Travel |Encounter '
                  r'|Combat |Refresh )?(Action):', '[b]\\1\\2\\3[/b]:', text)
    text = re.sub(r'\b(When Revealed|Setup|Forced|Valour Response|Response'
                  r'|Travel|Shadow|Resolution):', '[b]\\1[/b]:', text)
    text = re.sub(r'\b(Condition)\b', '[bi]\\1[/bi]', text)

    text = re.sub(r'\[bi\]', '***', text, flags=re.IGNORECASE)
    text = re.sub(r'\[\/bi\]', '***', text, flags=re.IGNORECASE)
    text = re.sub(r'\[b\]', '**', text, flags=re.IGNORECASE)
    text = re.sub(r'\[\/b\]', '**', text, flags=re.IGNORECASE)
    text = re.sub(r'\[i\]', '*', text, flags=re.IGNORECASE)
    text = re.sub(r'\[\/i\]', '*', text, flags=re.IGNORECASE)
    text = re.sub(r'\[u\]', '`__', text, flags=re.IGNORECASE)
    text = re.sub(r'\[\/u\]', '__', text, flags=re.IGNORECASE)
    text = re.sub(r'\[strike\]', '~~', text, flags=re.IGNORECASE)
    text = re.sub(r'\[\/strike\]', '~~', text, flags=re.IGNORECASE)

    text = text.replace('[willpower]', EMOJIS['[willpower]'])
    text = text.replace('[threat]', EMOJIS['[threat]'])
    text = text.replace('[attack]', EMOJIS['[attack]'])
    text = text.replace('[defense]', EMOJIS['[defense]'])
    text = text.replace('[leadership]', EMOJIS['[leadership]'])
    text = text.replace('[spirit]', EMOJIS['[spirit]'])
    text = text.replace('[tactics]', EMOJIS['[tactics]'])
    text = text.replace('[lore]', EMOJIS['[lore]'])
    text = text.replace('[baggins]', EMOJIS['[baggins]'])
    text = text.replace('[fellowship]', EMOJIS['[fellowship]'])
    text = text.replace('[unique]', EMOJIS['[unique]'])
    text = text.replace('[sunny]', EMOJIS['[sunny]'])
    text = text.replace('[cloudy]', EMOJIS['[cloudy]'])
    text = text.replace('[rainy]', EMOJIS['[rainy]'])
    text = text.replace('[stormy]', EMOJIS['[stormy]'])
    text = text.replace('[sailing]', EMOJIS['[sailing]'])
    text = text.replace('[eos]', EMOJIS['[eos]'])
    text = text.replace('[pp]', EMOJIS['[pp]'])

    text = text.replace('[', '`[')
    text = text.replace(']', ']`')
    text = text.replace('``', '')

    text = re.sub(r'`\[lsb\]`', '[', text, flags=re.IGNORECASE)
    text = re.sub(r'`\[rsb\]`', ']', text, flags=re.IGNORECASE)

    text = text.strip()
    text = re.sub(r' +(?=\n)', '', text)
    text = re.sub(r' +', ' ', text)
    text = re.sub(r'(?<!\n)\n(?!\n)', ' ', text)
    text = re.sub(r'\n+', '\n', text)
    return text


def format_side(card, prefix):  # pylint: disable=R0912,R0914,R0915
    """ Format a card side.
    """
    card_name = '**{}**'.format(card[prefix + lotr.CARD_NAME])
    card_type = card[prefix + lotr.CARD_TYPE]

    card_unique = ('{} '.format(EMOJIS['[unique]'])
                   if card.get(prefix + lotr.CARD_UNIQUE, '')
                   else '')

    sphere = card.get(prefix + lotr.CARD_SPHERE, '')
    if sphere in ('Leadership', 'Lore', 'Spirit', 'Tactics', 'Baggins',
                  'Fellowship'):
        card_sphere = '*{}* {} '.format(sphere,
                                        EMOJIS['[{}]'.format(sphere.lower())])
    elif sphere in ('Neutral', 'Boon', 'Burden', 'Nightmare', 'Upgraded'):
        card_sphere = '*{}* '.format(sphere)
    else:
        card_sphere = ''

    cost = card.get(prefix + lotr.CARD_COST, '')
    if cost == '' or card_type == 'Quest':
        card_cost = ''
    elif card_type == 'Hero':
        card_cost = ', *Threat Cost*: **{}**'.format(cost)
    else:
        card_cost = ', *Cost*: **{}**'.format(cost)

    engagement = card.get(prefix + lotr.CARD_ENGAGEMENT, '')
    if engagement == '' or card_type == 'Quest':
        card_engagement = ''
    else:
        card_engagement = ', *Engagement Cost*: **{}**'.format(engagement)

    if card_type == 'Quest':
        card_stage = ', **{}{}**'.format(
            card.get(prefix + lotr.CARD_COST, ''),
            card.get(prefix + lotr.CARD_ENGAGEMENT, ''))
    else:
        card_stage = ''

    card_skills = ''
    skill_map = {
        'threat': prefix + lotr.CARD_THREAT,
        'willpower': prefix + lotr.CARD_WILLPOWER,
        'attack': prefix + lotr.CARD_ATTACK,
        'defense': prefix + lotr.CARD_DEFENSE,
        'hitpoints': prefix + lotr.CARD_HEALTH,
        'progress': prefix + lotr.CARD_QUEST
    }
    for skill in skill_map:
        if card.get(skill_map[skill], '') != '':
            card_skills += '   {} {}'.format(EMOJIS['[{}]'.format(skill)],
                                             card[skill_map[skill]])

    card_skills = card_skills.strip()
    if card_skills:
        card_skills = '\n' + card_skills

    traits = card.get(prefix + lotr.CARD_TRAITS, '')
    card_traits = '' if traits == '' else '***{}***\n'.format(traits)

    keywords = update_text(card.get(prefix + lotr.CARD_KEYWORDS, ''))
    if keywords == '':
        card_keywords = ''
    elif keywords.endswith('`[inline]`'):
        card_keywords = '{} '.format(re.sub(r'`\[inline\]`$', '', keywords))
    else:
        card_keywords = '{}\n'.format(keywords)

    card_text = update_text(card.get(prefix + lotr.CARD_TEXT, ''))

    shadow = update_text(card.get(prefix + lotr.CARD_SHADOW, ''))
    card_shadow = (
        '' if shadow == ''
        else '\n**\\~\\~\\~\\~\\~\\~\\~\\~\\~\\~**\n{}'.format(shadow))

    victory = card.get(prefix + lotr.CARD_VICTORY, '')
    if victory == '':
        card_victory = ''
    elif card_type in ('Presentation', 'Rules'):
        card_victory = '\n**Page {}**'.format(victory)
    elif lotr.is_positive_or_zero_int(victory):
        card_victory = '\n**VICTORY {}**'.format(victory)
    else:
        card_victory = '**{}**\n'.format(victory)

    flavour = update_text(card.get(prefix + lotr.CARD_FLAVOUR, ''))
    card_flavour = '' if flavour == '' else '\n\n*{}*'.format(flavour)

    res = f"""{card_unique}{card_name}
{card_sphere}{card_type}{card_cost}{card_engagement}{card_stage}{card_skills}

{card_traits}{card_keywords}{card_text}{card_shadow}{card_victory}{card_flavour}"""
    return res


def format_card(card, spreadsheet_url, channel_url):  # pylint: disable=R0914
    """ Format the card.
    """
    card_type = card[lotr.CARD_TYPE]
    res_a = format_side(card, '')
    if (card.get(lotr.BACK_PREFIX + lotr.CARD_NAME) and
            card_type != 'Presentation' and
            (card_type not in ('Rules', 'Campaign', 'Contract', 'Nightmare') or
             card.get(lotr.BACK_PREFIX + lotr.CARD_TEXT))):
        res_b = '\n\n`SIDE B`\n\n{}'.format(format_side(card, lotr.BACK_PREFIX))
    else:
        res_b = ''

    adventure = card.get(lotr.CARD_ADVENTURE, '')
    if adventure == '':
        card_adventure = ''
    elif card_type == 'Campaign':
        card_adventure = '*Campaign*: {}\n'.format(adventure)
    else:
        card_adventure = '*Adventure*: {}\n'.format(adventure)

    encounter_set = card.get(lotr.CARD_ENCOUNTER_SET, '')
    additional_sets = card.get(lotr.CARD_ADDITIONAL_ENCOUNTER_SETS, '')
    if additional_sets != '':
        additional_sets = ' (+{})'.format(additional_sets).replace(';', ',')

    card_encounter_set = (
        '' if encounter_set == ''
        else '*Encounter Set*: {}{}\n'.format(encounter_set, additional_sets))

    card_set = re.sub(r'^ALeP - ', '', card[lotr.CARD_SET_NAME])
    card_number = '**#{}**'.format(card[lotr.CARD_NUMBER])
    card_id = '*id:* {}'.format(card[lotr.CARD_ID])

    icon = card.get(lotr.CARD_ICON, '')
    card_icon = '' if icon == '' else ' ({})'.format(icon)

    version = card.get(lotr.CARD_VERSION, '')
    card_version = '' if version == '' else ' **{}**'.format(version)

    quantity = card[lotr.CARD_QUANTITY]
    removed_easy_mode = card.get(lotr.CARD_EASY_MODE, 0)
    if removed_easy_mode > 0:
        easy_mode = '/x{}'.format(quantity - removed_easy_mode)
    else:
        easy_mode = ''

    card_quantity = '(x{}{})'.format(quantity, easy_mode)

    deck_rules = card.get(lotr.CARD_DECK_RULES, '')
    card_deck_rules = ('' if deck_rules == ''
                       else '```{}```\n'.format(deck_rules))

    if card.get(lotr.CARD_RINGSDB_CODE):
        ringsdb_url = '<https://test.ringsdb.com/card/{}>\n'.format(
            card[lotr.CARD_RINGSDB_CODE])
    else:
        ringsdb_url = ''

    row_url = '<{}&range=A{}>'.format(spreadsheet_url, card[lotr.ROW_COLUMN])
    if channel_url:
        channel_url = '<{}>'.format(channel_url)

    res = f"""{res_a}{res_b}

{card_set}{card_icon}, {card_number}{card_version} {card_quantity}
{card_encounter_set}{card_adventure}{card_id}

{card_deck_rules}{ringsdb_url}{row_url}
{channel_url}"""
    res = re.sub(r'\n{3,}', '\n\n', res)
    res = res.replace('\n\n', '\n` `\n')
    return res


class MyClient(discord.Client):
    """ My bot class.
    """

    channels = {}


    async def on_ready(self):
        """ Invoked when the client is ready.
        """
        logging.info('Logged in as %s (%s)', self.user.name, self.user.id)
        for channel in self.get_all_channels():
            self.channels[channel.name] = (channel.id, channel.guild.id)


    async def _send_channel(self, channel, content):
        for i, chunk in enumerate(split_result(content)):
            if i > 0:
                await asyncio.sleep(SLEEP_TIME)

            await channel.send(chunk)


    async def _process_cron_command(self, message):  #pylint: disable=R0912
        """ Process a cron command.
        """
        command = re.sub(r'^!cron ', '', message.content).split('\n')[0]
        logging.info('Received cron command: %s', command)
        if command == 'hello':
            await message.channel.send('hello')
        elif command == 'test':
            await message.channel.send('passed')
        elif command == 'thank you':
            await message.channel.send('you are welcome')
        elif command == 'log':
            res = await get_log()
            if not res:
                res = 'no cron log found'

            await self._send_channel(message.channel, res)
        elif command == 'errors':
            res = await get_errors()
            if not res:
                res = 'no cron log found'

            await self._send_channel(message.channel, res)
        else:
            await message.channel.send('excuse me?')


    async def _new_target(self, content):
        """ Set new playtesting targets.
        """
        error_message = """incorrect command format: {}
try something like:
```
!playtest new
Deadline: tomorrow.
1. Escape From Dol Guldur (solo)
2. Frogs deck
```
"""
        lines = [line.strip() for line in content.split('\n')[1:]]
        nums = set()
        description = []
        targets = []
        for line in lines:
            if not re.match(r'^[0-9]+\.? ', line):
                if nums:
                    return error_message.format('no number for a target')

                description.append(line)
                continue

            if '~~' in line:
                return error_message.format('a target is already crossed out')

            num, title = line.split(' ', 1)
            num = re.sub(r'\.$', '', num)
            if num in nums:
                return error_message.format(
                    'a duplicate target number "{}"'.format(num))

            nums.add(num)
            targets.append({'num': num,
                            'title': title,
                            'completed': False,
                            'user': None})

        if not targets:
            return error_message.format('no targets specified')

        data = {'targets': targets,
                'description': '\n'.join(description)}

        async with playtest_lock:
            with open(PLAYTEST_PATH, 'w') as obj:
                json.dump(data, obj)

        playtest_message = """----------
New playtesting targets:
{}""".format(format_playtest_message(data))
        if PLAYTEST_CHANNEL in self.channels:
            await self._send_channel(
                self.get_channel(self.channels[PLAYTEST_CHANNEL][0]),
                playtest_message)

        return ''


    async def _complete_target(self, content, num, user, url):
        """ Complete playtesting target.
        """
        if not re.match(r'^[0-9]+$', num):
            return 'target number "{}" doesn\'t look correct'.format(num)

        if len(content.split('\n', 1)) == 1:
            return 'please add a playtesting report'

        async with playtest_lock:
            with open(PLAYTEST_PATH, 'r+') as obj:
                data = json.load(obj)

                nums = [target['num'] for target in data['targets']]
                if num not in nums:
                    return 'target "{}" not found'.format(num)

                nums = [target['num'] for target in data['targets']
                        if not target['completed']]
                if num not in nums:
                    return 'target "{}" already completed'.format(num)

                for target in data['targets']:
                    if target['num'] == num:
                        target['completed'] = True
                        target['user'] = user
                        break

                obj.seek(0)
                obj.truncate()
                json.dump(data, obj)

        all_targets = ('All targets completed now!'
                       if all(target['completed']
                              for target in data['targets'])
                       else '')
        playtest_message = """----------
Target "{}" completed. Link: {}
{}
{}""".format(num, url, format_playtest_message(data), all_targets)
        if PLAYTEST_CHANNEL in self.channels:
            await self._send_channel(
                self.get_channel(self.channels[PLAYTEST_CHANNEL][0]),
                playtest_message)

        return ''


    async def _update_target(self, params):  # pylint: disable=R0912
        """ Update playtesting target.
        """
        nums = set()
        while params:
            param = params[0]
            if not param:
                params.pop(0)
            elif re.match(r'^[0-9]+$', param):
                if param in nums:
                    return 'a duplicate target number "{}"'.format(param)

                params.pop(0)
                nums.add(param)
            else:
                break

        if not nums:
            return 'no target number(s) specified'

        user = ' '.join(params)
        async with playtest_lock:
            with open(PLAYTEST_PATH, 'r+') as obj:
                data = json.load(obj)

                existing_nums = set(target['num']
                                    for target in data['targets'])
                for num in nums:
                    if num not in existing_nums:
                        return 'target "{}" not found'.format(num)

                for target in data['targets']:
                    if target['num'] in nums:
                        if user:
                            target['completed'] = True
                            target['user'] = user
                        else:
                            target['completed'] = False
                            target['user'] = None

                obj.seek(0)
                obj.truncate()
                json.dump(data, obj)

        all_targets = ('All targets completed now!'
                       if all(target['completed']
                              for target in data['targets'])
                       else '')
        playtest_message = """----------
Targets updated.
{}
{}""".format(format_playtest_message(data), all_targets)
        if PLAYTEST_CHANNEL in self.channels:
            await self._send_channel(
                self.get_channel(self.channels[PLAYTEST_CHANNEL][0]),
                playtest_message)

        return ''


    async def _add_target(self, content):
        """ Add additional playtesting targets.
        """
        lines = [line.strip() for line in content.split('\n')[1:]]
        nums = set()
        description = []
        targets = []
        for line in lines:
            if not re.match(r'^[0-9]+\.? ', line):
                if nums:
                    return 'no number for a target'

                description.append(line)
                continue

            if '~~' in line:
                return 'a target is already crossed out'

            num, title = line.split(' ', 1)
            num = re.sub(r'\.$', '', num)
            if num in nums:
                return 'a duplicate target number "{}"'.format(num)

            nums.add(num)
            targets.append({'num': num,
                            'title': title,
                            'completed': False,
                            'user': None})

        if not description and not targets:
            return 'no new desription or targets specified'

        async with playtest_lock:
            with open(PLAYTEST_PATH, 'r+') as obj:
                data = json.load(obj)

                existing_nums = set(target['num']
                                    for target in data['targets'])
                for num in nums:
                    if num in existing_nums:
                        return 'a duplicate target number "{}"'.format(num)

                if description:
                    data['description'] = '\n'.join(description)

                data['targets'].extend(targets)
                obj.seek(0)
                obj.truncate()
                json.dump(data, obj)

        playtest_message = """----------
Targets added.
{}""".format(format_playtest_message(data))
        if PLAYTEST_CHANNEL in self.channels:
            await self._send_channel(
                self.get_channel(self.channels[PLAYTEST_CHANNEL][0]),
                playtest_message)

        return ''


    async def _remove_target(self, params):
        """ Remove existing playtesting targets.
        """
        nums = set()
        while params:
            param = params[0]
            if not param:
                params.pop(0)
            elif re.match(r'^[0-9]+$', param):
                if param in nums:
                    return 'a duplicate target number "{}"'.format(param)

                params.pop(0)
                nums.add(param)
            else:
                return 'target number "{}" doesn\'t look correct'.format(param)

        if not nums:
            return 'no target number(s) specified'

        async with playtest_lock:
            with open(PLAYTEST_PATH, 'r+') as obj:
                data = json.load(obj)

                existing_nums = set(target['num']
                                    for target in data['targets'])
                for num in nums:
                    if num not in existing_nums:
                        return 'target "{}" not found'.format(num)

                data['targets'] = [target for target in data['targets']
                                   if target['num'] not in nums]
                obj.seek(0)
                obj.truncate()
                json.dump(data, obj)

        playtest_message = """----------
Targets removed.
{}""".format(format_playtest_message(data))
        if PLAYTEST_CHANNEL in self.channels:
            await self._send_channel(
                self.get_channel(self.channels[PLAYTEST_CHANNEL][0]),
                playtest_message)

        return ''


    async def _process_playtest_command(self, message):  # pylint: disable=R0911,R0912,R0915
        """ Process a playtest command.
        """
        command = re.sub(r'^!playtest ', '', message.content).split('\n')[0]
        logging.info('Received playtest command: %s', command)
        if command == 'new':
            try:
                error = await self._new_target(message.content)
            except Exception as exc:
                logging.error(str(exc))
                await message.channel.send(
                    'unexpected error: {}'.format(str(exc)))
                return

            if error:
                await message.channel.send(error)
                return

            await message.channel.send('done')
        elif command.startswith('complete '):
            try:
                num = re.sub(r'^complete ', '', command)
                user = re.sub(r'#.+$', '', str(message.author))
                error = await self._complete_target(message.content, num, user,
                                                    message.jump_url)
            except Exception as exc:
                logging.error(str(exc))
                await message.channel.send(
                    'unexpected error: {}'.format(str(exc)))
                return

            if error:
                await message.channel.send(error)
                return

            await message.channel.send('done')
        elif command.startswith('update '):
            try:
                params = re.sub(r'^update ', '', command).split(' ')
                error = await self._update_target(params)
            except Exception as exc:
                logging.error(str(exc))
                await message.channel.send(
                    'unexpected error: {}'.format(str(exc)))
                return

            if error:
                await message.channel.send(error)
                return

            await message.channel.send('done')
        elif command == 'add':
            try:
                error = await self._add_target(message.content)
            except Exception as exc:
                logging.error(str(exc))
                await message.channel.send(
                    'unexpected error: {}'.format(str(exc)))
                return

            if error:
                await message.channel.send(error)
                return

            await message.channel.send('done')
        elif command.startswith('remove '):
            try:
                params = re.sub(r'^remove ', '', command).split(' ')
                error = await self._remove_target(params)
            except Exception as exc:
                logging.error(str(exc))
                await message.channel.send(
                    'unexpected error: {}'.format(str(exc)))
                return

            if error:
                await message.channel.send(error)
                return

            await message.channel.send('done')
        elif command.startswith('random '):
            num = re.sub(r'^random ', '', command)
            if lotr.is_positive_int(num):
                res = random.randint(1, int(num))
                await message.channel.send(str(res))
            else:
                await message.channel.send(
                    '"{}" is not a positive integer'.format(num))
        else:
            await message.channel.send('excuse me?')


    async def _get_card(self, command):
        """ Get the card information.
        """
        data = await read_card_data()
        if re.match(r' [0-9]+$', command):
            parts = command.split(' ')
            name = ' '.join(parts[:-1])
            num = parts[-1]
        else:
            name = command
            num = 1

        name = lotr.normalized_name(name)
        matches = [m for m in [
            (card, card_match(
                card[lotr.CARD_NORMALIZED_NAME],
                card.get(lotr.BACK_PREFIX + lotr.CARD_NORMALIZED_NAME, ''),
                name))
            for card in data['data']] if m[1] > 0]
        if not matches:
            return 'no cards found'

        matches.sort(key=lambda m: (
            m[1],
            m[0][lotr.CARD_NAME],
            m[0].get(lotr.CARD_SET_RINGSDB_CODE, 0),
            lotr.is_positive_or_zero_int(m[0][lotr.CARD_NUMBER])
            and int(m[0][lotr.CARD_NUMBER]) or 0,
            m[0][lotr.CARD_NUMBER]))

        card = matches[num - 1][0]
        if card[lotr.CARD_NORMALIZED_NAME] in self.channels:
            channel_id, guild_id = self.channels[
                card[lotr.CARD_NORMALIZED_NAME]]
            channel_url = ('https://discord.com/channels/{}/{}'
                           .format(guild_id, channel_id))
        else:
            channel_url = ''
        return format_card(card, data['url'], channel_url)


    async def _process_card_command(self, message):
        """ Process a card command.
        """
        command = re.sub(r'^!alepcard ', '', message.content).split('\n')[0]
        logging.info('Received card command: %s', command)
        if command == 'this':
            command = message.channel.name

        try:
            res = await self._get_card(command)
        except Exception as exc:
            logging.error(str(exc))
            await message.channel.send(
                'unexpected error: {}'.format(str(exc)))
            return

        await self._send_channel(message.channel, res)


    async def on_message(self, message):
        """ Invoked when a new message posted.
        """
        try:
            if message.author.id == self.user.id:
                return

            if message.content.startswith('!cron '):
                await self._process_cron_command(message)
            elif message.content.startswith('!playtest '):
                await self._process_playtest_command(message)
            elif message.content.startswith('!alepcard '):
                await self._process_card_command(message)
        except Exception as exc:
            logging.exception(str(exc))


if __name__ == '__main__':
    os.chdir(WORKING_DIRECTORY)
    init_logging()
    MyClient().run(get_token())
